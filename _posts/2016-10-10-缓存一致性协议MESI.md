---
layout: post
title: 缓存一致性协议(MESI)
category: [JAVA]
tags: [JAVA]
---

之前提到过的AQS同步框架的实现底层是依靠volatile和cas来操作的.

其中volatile因为其对所有线程的可见性从而保证实现

那为什么volatile能保证所以线程的可见性呢?

#### 因为volatile每次写之后的其他线程会立刻知道,并且将本地缓存中对应的共享变量设置为无效,直接从主内存中获取,而每次写之后,最新的值都会立刻同步回主内存,因此能保证线程可见性

那具体是如何操作的呢?

#### 答案是基于缓存一致性协议

##### 下面我参考了部分资料,详细说明下原理

首先每个CPU都会有自己的操作内存,比如L1缓存,L2,L3,L1是不能直接和主内存直接通信的,只能跟L2通信,然后L2和L3,L3和主内存,以此内推

那结构就是 CPU -- 本地缓存 -- 主内存

![](http://pic.woowen.com/mesicupcache.jpg)

针对volatile变量的写,其实就是对CPU本地缓存的写

本地缓存的最小操作单元是缓存行,每个64byte(X86架构下,其他CPU可能是128byte),而每个缓存行也会有个两个状态位来维护该缓存行所处的状态

缓存行的状态就是MESI协议规定的4种,当然还有更高级的MESIF(I7 CPU使用)的协议和AMD使用的MOESI协议,这边不做更多深入

* M : 表示修改的,表示该缓存行刚被修改过
* E : 表示独占的,其他CPU无法操作该缓存行
* S : 表示共享的,其他CPU本地缓存中也会有同样的一份本地缓存,他们中存储的value是一致的
* I : 表示无效的,表示该缓存行中的内容无效.直接从主内存重新获取一份

###### 当操作volatile去写一个变量时,就会去写该变量存储所处的缓存行,因为这个变量是共享的,所有CPU本地都有一份,因此他的状态是S,修改之后,会变成M,而其他的CPU会立刻收到通知,的值本地的共享变量已经被修改,那么就会将本地的缓存行设置为I即为无效的,因此当其他CPU要再次读取这个共享变量的时候,发现他的缓存行状态是I,那么就会直接去主内存中获取.从而实现功能

##### 至于其他CPU如何知道,他是通过"窥探"这一功能实现的,窥探是属于窥探协议,所有的内存传输都发生在一条共享的总线上,所有的CPU都可以获得这个总线,缓存不仅仅只有在做数据传输时才会跟总线发生交流,而是时时刻刻的去窥探总线上发生的数据交换,跟踪其他缓存的变化,这样,当其他CPU的缓存发生状态变更时,所有的CPU都会立刻得到通知

##### 所以当CPU对缓存行修改,那么状态变成了M,其他CPU就会通过窥探立刻得知该缓存行已经被修改,于是设置本地缓存行对应的缓存为I(无效),当CPU需要读取共享变量时,发现他的状态是I,那么就会强制从主内存中重新读取

#### 伪共享

##### 前面说过每个缓存行具有64byte的大小,有些CPU甚至是128byte,而java中int 类型是4byte,long是8byte,那么一个缓存行就可能存储16个int变量,以及8个long变量,势必就会存在一个缓存行存储了多个共享变量,而这多个共享变量可能是热点数据,因此他的值是在不断变化的

##### 如果CPU1的共享变量A存在缓存行M中,CPU2的共享变量B也存在缓存行M中,两个CPU不断的对这个缓存行进行修改,那么就会造成不断的无效缓存行,不断的从主内存中读取到L3缓存中.而L3缓存跟主内存的交互速度是很慢的.

![](http://pic.woowen.com/mesicpucachespeed.png)

从而导致性能问题,在高并发的环境下就更加明显

如何解决?

通过字符填充来进行,之前说过每个缓存行64byte,那么当存储一个热点数据的时候,我们只要加该热点数据+字符填充 = 64byte,正好占用了一个缓存行,那么CPU对于该缓存行来说就是只操作一个热点数据,就不存在伪共享的问题,也就提升了高并发下的性能,disruptor通过对ringbuffer进行字符填充,保证ringbuffer单独存储在一个缓存行中,从而提高性能.


##### 参考

<http://www.infoq.com/cn/articles/cache-coherency-primer>

<http://ifeve.com/disruptor-cacheline-padding/>

<http://www.cnblogs.com/jiayy/p/3246133.html>

<http://ifeve.com/disruptor-cacheline-padding/>
