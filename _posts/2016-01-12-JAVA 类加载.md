---
layout: post
title: JAVA 类加载机制
category: [JAVA]
tags: [JAVA]
---

类加载的生命周期分为
* 1.加载
* 2.验证
* 3.准备
* 4.解析
* 5.初始化
* 6.使用
* 7.卸载

![](http://pic.woowen.com/classloaderlife.jpg)

### 类加载时机

java对于加载操作却没有明确的定义,在初始化之前,加载验证等操作已经完成,因此交给jvm自己去做

类加载是通过类加载器去完成的,它可以是饿汉也可以是懒汉

* 饿汉: 只要有其他类引用了它就会去加载
* 懒汉: 等类初始化发生的时候再去加载

### 初始化时机

Java中,只有5种情况下必须对类进行初始化操作

* 1.遇到```new,getstatic,putstatic,invokestatic``` 4条字节码的时候,如果类没有进行过初始化,会先触发初始化操作,比如使用new 关键字生成新对象,读取或者设置一个静态字段(被final修饰,已在编译期间就把结果放入常量池除外),以及调用一个静态方法的时候

* 2.使用反射对一个类进行反射操作时,如果这个类没有初始化过,需要先触发初始化

* 3.当初始化一个类时,发现其父类还没有初始化,需要先触发父类的初始化

* 4.jvm启动时,需要一个main执行方法,会先去初始化这个主类

* 5.使用动态代理,通过methodhandle调用,最后解析结果中有REF_getStatic、REF_putStatic、REF_in-vokeStatic方法句柄,如果这个类没初始化需要先对他进行初始化

除了上面5种,其他的引用类方式都不会主动触发类的初始化

### 加载

* 1.通过类的全限定名字获取它的二进制字节流

* 2.将这个字节流所代表的静态结构转化成方法区运行的数据结构

* 3.在内存中生成一个class的对象,作为方法区这个类的访问入口

### 验证

* 1.文件格式验证
* 2.元数据验证,比如这个类释放继承了final 类,如果其父类是抽象类,子类是否实现了父类定义的方法等
* 3.字节码验证
* 4.符号引用验证

这部分我觉得简单了解就好了

### 准备

准备阶段正是为类分配内存,并设置类变量初始值的阶段,这个阶段进行内存分配,仅包括类变量(static 变量),而不包括实例变量,这边的初始值一般是该类型的初始值,譬如``` public static int a = 1```,这个时候a在准备阶段的初始值为0,而不是1

### 解析

将虚拟机中常量池的符号引用替换为直接引用的过程

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。   

直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

### 类加载器

从java的角度出发,只有两种类加载器,一种是启动类加载器(bootstrap class-loader,c++实现,内嵌jvm中),一种是其他类加载器

从java开发角度出发,可以分为三种

* 启动类加载器,这个类负责将放在java_home/lib目录中,或者被```-Xbootclasspath```参数指定的路径中,并且是jvm识别的(按照文件名识别)类库加载到jvm中

* 扩展类加载器,可以被直接使用

* 应用程序类加载器,负责加载用户路径,ClassPath路径上指定的类库,如果程序中没有自定义类加载器,那么这个就是默认的

![](http://pic.woowen.com/classloadtype.jpg)

#### 上图这种类加载器之间的层次模型,称为类加载器的双亲委派模型

双亲委派模型要求,除了顶层的启动类加载器外,其他所有的加载器应当有自己的父类加载器

#### 如果一个类加载器收到了加载的请求,他不会直接去加载这个类,而是把这个请求委派给父类的加载器去执行,因此所有的类加载请求,最终都会传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成这个加载请求时(它搜索的范围没有找到这个类),子类加载器才会尝试去加载


