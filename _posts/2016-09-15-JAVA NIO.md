---
layout: post
title: JAVA NIO
category: [JAVA]
tags: [JAVA,网络]
---

JAVA NIO 主要由几个部分组成,分别是Buffer,Channel,Selector,这个问题网上资料很多,我这边再次汇总下,自己梳理下,方便理解

### Buffer

Nio中的Buffer有两种模式,分别是读取模式和写入模式

含有4个属性

* Capacity 缓冲区的容量,在创建时设置,不能更改,因此容量这块也是跟netty不同的地方,不能动态扩容,想要扩容只能重新申请,然后复制
* Limit 缓冲区读或者写的索引限制
* Position 读取或者写入的位置,下一个被读取的位置,或者下一个被写入的位置
* Mark 备注,可以通过mark来回归上次写的位置或者读取的位置,mark(): mark = position, remark(): position = mark;

读取模式和写入模式通过方法```flip()```来翻转

![](http://pic.woowen.com/bufferstart.png)

写入之前,position = 0, limit = capacity

![](http://pic.woowen.com/bufferafterread.png)

写入之后,position 为下一个要写入的索引值

![](http://pic.woowen.com/bufferread.png)

在切换模式之后,position = 0,表示从0开始读取,每次读取一个字节,position位置向后移动,limit表示已经写入的最大位置,也就是能读取到的所有字节位置


### Channel

Channel用于向Buffer提供数据,或者从Buffer中读取数据
Channel可以异步读写(阻塞和非阻塞模式选择)

* FileChannel 通过文件中读写数据
* DatagramChannel 通过UDP读写数据 
* SocketChannel 通过TCP读写数据
* ServerSocketChannel 可以监听TCP连接,每次新进入一个连接都会创建一个SocketChannel

### Selector(选择器)

这块是这部分的重点

Selector可以检查多个Channel是否为读写事件做好准备,一个Selector可以管理多个Channel
Chanenl通过注册与Selector建立关系

Selector会创建3个Set集合

* Key Set: 所有通过注册到该Selector的Channel都能获得一个SelectionKey,并加入这个Set集合中
* Selected-key Set: Channel读或者写准备就绪,就会放入这个集合中
* Cancelled-key Set: key已经取消,但是Channel还没有取消注册或者该key的Channel已经被关闭的集合

Selector是线程安全的,但是它的Sets并不是线程安全的

将Channel注册到Selector的时候,可以选择不同类型的事件,表示该Channel会对什么类型的事件做出准备,这几种事件包含

* Connect
* Accept
* Read
* Write

SelectionKey定义了4个静态常量

```JAVA

// 4中事件常量
public static final int OP_READ = 1 << 0;
public static final int OP_WRITE = 1 << 2;
public static final int OP_CONNECT = 1 << 3;
public static final int OP_ACCEPT = 1 << 4;

// key和感兴趣的事件对应的集合,可以通过SelectionKey知道该Channel对哪些事件敢兴趣
// 一个Channel可以对多个事件感兴趣
public abstract int interestOps();
// 准备就绪的key集合
public abstract int readyOps();

```

当一个Selector中已经注册了几个Channel的时候,可以通过```Select()```方法获得准备就绪的Channel

```JAVA

// 如果没有Channel准备就绪,立刻返回0
public abstract int selectNow() throws IOException;

// 阻塞规定时间
public abstract int select(long timeout) throws IOException;

// 一直阻塞,直到有Channel准备就绪返回
public abstract int select() throws IOException;

// 唤醒某个被阻塞的线程
public abstract Selector wakeup();

// 关闭Selector,注册到该Selector的SelectionKey就会失效,Channel不会关闭
public abstract void close() throws IOException;

```

#### Selector的内部实现
Selector主要通过系统函数来实现select/poll/epoll

详细原理涉及到平台的实现原理<http://www.cnblogs.com/Anker/p/3265058.html>,这边不细说,主要说下区别

![](http://pic.woowen.com/epollpoll.png)

### Reactor/Proactor

I/O复用需要用到事件分发器, 事件分发器的作用是监听所有的fd,当其中读/写就绪的时候就会通知之前注册的事件处理器去处理I/O操作
事件分发器设计两种模式Reactor/Proactor

#### Reactor

Reactor 基于同步I/O,事件分发器等待事件发生,事件发生之后就把这个事件传给之前注册的事件处理器(回调函数)进行处理,由事件处理器来做实际的I/O操作

![](http://pic.woowen.com/reactor.png)

* 事件处理器在事件分发器上注册监听的事件或者回调函数
* 事件处理器等待事件发生
* 事件发生,事件分发器将事件传递给事件处理器
* 事件处理器自己完成I/O操作以及其他业务处理

##### 事件分发器只进行事件分发,事件处理器自己进行I/O处理

#### Proactor

Proactor 基于异步I/O

![](http://pic.woowen.com/proactor.png)

* 事件处理器对事件分发器发起异步I/O请求,提供存放数据的缓冲区,数据大小,回调函数等参数信息
* 事件分发器等待事件发生
* 事件发生,事件分发器请求操作系统完成I/O操作,系统完成异步I/O操作之后通知事件分发器,事件分发器转发完成后的事件给事件处理器
* 事件处理器针对已经完成I/O操作的事件进行数据处理

##### 事件处理器不进行I/O读写操作,读写操作交由系统去完成,事件处理器只处理完成之后的事件(常规的业务数据处理,不包含I/O操作)


