<h3 id="iocpucpu">索引可以提高数据的检索效率，也可以降低数据库的IO成本，并且索引还可以降低数据库的排序成本。排序分组操作主要消耗的就是CPU资源和内存，所以能够在排序分组操作中好好的利用索引将会极大地降低CPU资源的消耗。</h3>

<h4 id="section">如何判定是否需要创建索引</h4>

<ul>
  <li>
    <p>1.<code>较频繁地作为查询条件的字段。</code>这个都知道。什么是教频繁呢？分析你执行的所有SQL语句。最好将他们一个个都列出来。然后分析。发现其中有些字段在大部分的SQL语句查询时候都会用到，那么就果断为他建立索引。</p>
  </li>
  <li>
    <p>2.唯一性太差的字段不适合建立索引，什么是唯一性太差的字段。如状态字段。类型字段。那些只存储固定几个值的字段。例如用户登录状态。消息的status。等。这个涉及到了索引扫描的特性。<code>例如：通过索引查找键值为A和B的某些数据，通过A找到某条相符合的数据，这条数据在X页上面，然后继续扫描，又发现符合A的数据出现在了Y页上面，那么存储引擎就会丢弃X页面的数据，然后存储Y页面上的数据，一直到查找完所有对应A的数据，然后查找B字段，发现X页面上面又有对应B字段的数据，那么他就会再次扫描X页面，等于X页面就会被扫描2次甚至多次。</code>以此类推，所以同一个数据页可能会被多次重复的读取，丢弃，在读取，这无疑给存储引擎极大地增加了IO的负担。</p>
  </li>
  <li>
    <p>3.<code>更新太频繁地字段不适合创建索引，</code>当你为这个字段创建索引时候，当你再次更新这个字段数据时，数据库会自动更新他的索引，所以当这个字段更新太频繁地时候那么就是不断的更新索引，性能的影响可想而知。大概被检索几十次会更新一次的字段才比较符合建立索引的规范。而如果一个字段同一个时间段内被更新多次，那么果断不能为他建立索引。</p>
  </li>
  <li>
    <p>4.不会出现在where条件中的字段不该建立索引。这个相信大家都知道。</p>
  </li>
</ul>
