---
layout: post
title: 深入理解jvm阅读 之 GC
category: [JAVA,JVM,图书/感想]
tags: [JAVA,JVM,图书]
---

阅读了深入理解java虚拟机,主要用来记录,方便自己整理记录

#### GC Roots
通过一些GC Roots对象作为起始点,从这些节点开始向下搜索,当一个对象到GC Roots没有任何引用链相关联,那么可以说这个对象是不可用的

可作为GC Roots的对象包括

* 1.栈帧中的本地变量表中引用的对象
* 2.方法区中类静态属性引用的对象jvm
* 3.方法区中常量引用的对象
* 4.JNI引用的对象

通过GCRoots 对于无法链接的对象进行标记

被标记的对象可以通过finalize方法进行自救避免被GC释放,被标记的对象放放入到一个队列中,然后由低优先级的finalize线程去执行,但是每个对象的finalize方法只能被调用一次,也就是说对象只能自救一次

避免使用finalize方法进行自救,运行成本大

#### 引用可以分为4种,分为强引用,软引用,弱引用,虚引用

强引用: 代码中非常常见的,例如```Object obj = new Object()```,只要强引用还存在,GC永远不会回收被引用的对象

软引用: 一些有用,但不是必须的对象,对于软引用关联的对象,会在发生内存溢出之前将这些对象列为可回收范围之中,进行二次回收

弱引用: 非必须对象,比软引用更弱一些

虚引用: 最弱的一种引用关系,为一个对象设置虚引用的唯一目的就是能在这个对象被GC回收时收到一个系统通知


### 垃圾回收算法

新生代

标记-复制-清除

Eden Survivor1 Survivor2 默认大小 8:1
所以新生代中内存分配Eden 80% + S1 10% + S2 10%
进行新生代的垃圾回收之后,会将Eden和S1中的存活下来的对象复制到S2中,然后对Eden和S1进行全部清理,确保没有内存碎片的存在,如果S2中无法保存下Eden和S1中存活的对象,那么这些对面将会直接放入老年代中

老年代

标记-整理-清除

GC的时候必须停顿,因为进行可达性分析,GCRoots的时候,不能出现某个对象不断的重复引用,取消引用,因此需要有一个快照,在快照中执行分析

OOPMap,在编译期间,jvm就会把对象的引用情况记录在oopmap结构中,gc扫描的时候就可以直接拿来使用.而不用遍历分析庞大的类依赖

Eden中的对象经过一次MinorGC之后活了下来,那么age+1,当age 到达15后就晋升到老年代中. 这个age阈值是可以通过jvm参数设置的.

前提是Edne gc之后活了下来,并且survivor中可以容纳他,如果不能容纳,那么直接进入老年代中

java8中使用元空间来替代了永久代,因此使用jstat方法输出的时候,会有一个M,替代了1.7中的P(永久代)
这个M指的就是元空间

所以,当别人问起你java的内存空间时候,别再说jvm中是新生代,老年代和永久代了.
应该是新生代,老年代,元空间

元空间(metaspace)的好处就在于可以动态的分配本地内存,那么元空间的大小限制就只依赖本机的内存大小了.不在出现java7中永久代内存空间不够用而FullGC的情况出现了.


#### 垃圾回收器

* 1.串行(Serial)收集器
* 2.ParNew收集器,多线程串行收集器

![](http://pic.woowen.com/parnew.jpg)

* 3.Parallel Scavenge(并行收集器) 控制吞吐量,具有自适应调节策略-JVM会根据当前系统的运行情况收集性能监控信息,动态的调整参数,提供合适的吞吐量和停顿时间

* 4.Serial Old,串行的老年代版本收集器

![](http://pic.woowen.com/serialold.jpg)

* 5.Parallel Old,并行收集器的老年代版本,使用多线程和"标记-整理"算法

![](http://pic.woowen.com/parallelold.jpg)

* 6.CMS 收集器,基于"标记-清除"算法实现,主要分为,初始标记,并发标记,重新标记,并发清除

![](http://pic.woowen.com/cms.jpg)

* 7.G1收集器,分代收集,基于"标记-整理"算法,所以不会产生内存碎片,可预测的停顿,他将整个java堆划分为多个大小相等的独立区域,虽然保留了新生代和老年代,但是她们不在是物理隔离,他们都是一部分独立区域,他可以有计划的避免在整个java堆(heap)中进行full gc,根据没有独立区域回收所获得的内存空间,以及回收耗时,在后台维护一个优先队列,每次根据允许收集时间,优先回收价值最大的独立区域,这种使用独立区域划分内存空间,以及有优先级的区域回收方式,保证G1在有限的回收时间内,尽可能的提升回收效率

![](http://pic.woowen.com/G1.jpg)




